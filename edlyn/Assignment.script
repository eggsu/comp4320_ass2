def Assignment():
  set_safety_mode_transition_hardness(1)
  set_gravity([0.0, 0.0, 9.82])
  set_tcp(p[0.0,0.0,0.0,0.0,0.0,0.0])
  step_count_c8646680_e94a_4b12_b202_97d53fc95e7b = 0.0
  thread Step_Counter_Thread_5e55d3e9_f4bb_44ae_938e_307c5aa9713b():
    while (True):
      step_count_c8646680_e94a_4b12_b202_97d53fc95e7b = step_count_c8646680_e94a_4b12_b202_97d53fc95e7b + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_5e55d3e9_f4bb_44ae_938e_307c5aa9713b()
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_target_payload(0.001000, [0.000000, 0.000000, 0.000000], [0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  global Back=p[0.0,0.3,0.0,-1.5707963267948966,-1.3978189091119739E-16,-5.25851784609816E-17]
  global Plane_1=p[-0.4,-0.2355320069913949,0.0,3.1063410397360093E-16,1.6676858503224494E-16,-2.0943951023931957]
  global Side=p[0.3,0.0,0.0,-5.937390976340237E-16,1.5707963267948966,-1.7572917985469221E-16]
  global Table=p[0.0,0.0,0.0,3.141592653589793,1.9236706937217898E-16,0.0]
  global letter_start=p[-0.5128693799585483,-0.36841181777544263,0.07,2.2219092988032063,2.220399308837135,-3.657049393105943E-4]
  # begin: URCap Installation Node
  #   Source: External Control, 1.0.4, FZI Research Center for Information Technology
  #   Type: External Control
  # end: URCap Installation Node
  global start_corner_p=p[-.605162114047, -.393119672738, .069976711230, 2.740105030274, 1.531900872004, .002608103602]
  global start_corner_q=[-2.3789289633380335, -2.4362651310362757, -1.4565258026123047, -0.8222113412669678, 1.5689738988876343, 1.3103644847869873]
  def move_up():
    $ 177 "move_up" "noBreak"
    $ 178 "MoveL"
    $ 179 "curr_pos≔pose_add(curr_pos, p[0,0,-1/100,0,0,0])"
    global curr_pos= pose_add (curr_pos, p[0,0,-1/100,0,0,0])
    $ 180 "curr_pos" "breakAfter"
    movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
  end
  def move_down():
    $ 181 "move_down" "noBreak"
    $ 182 "MoveL"
    $ 183 "curr_pos≔pose_add(curr_pos, p[0,0,1/100,0,0,0])"
    global curr_pos= pose_add (curr_pos, p[0,0,1/100,0,0,0])
    $ 184 "curr_pos" "breakAfter"
    movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
  end
  while (True):
    $ 1 "Robot Program"
    $ 3 "LETTERS≔[5,4,12,25,14,27,12,9,5,23,27,12]"
    global LETTERS=[5,4,12,25,14,27,12,9,5,23,27,12]
    $ 4 "num_letters≔12"
    global num_letters=12
    $ 5 "counter≔0"
    global counter=0
    $ 6 "MoveJ"
    $ 7 "start_corner" "breakAfter"
    movej(get_inverse_kin(pose_trans(letter_start, pose_trans(p[.651827027168, .309409199398, .071053077952, -2.740114821230, -1.531898493235, -.002604394761], start_corner_p)), qnear=start_corner_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 8 "'start height: 70mm'"
    # 'start height: 70mm'
    $ 9 "MoveJ"
    $ 10 "curr_pos≔pose_trans(pose_sub(get_actual_tcp_pose(),letter_start), p[0,0,0,0,0,0])"
    global curr_pos= pose_trans ( pose_sub ( get_actual_tcp_pose (),letter_start), p[0,0,0,0,0,0])
    $ 11 "Loop counter<num_letters"
    while (counter<num_letters):
      $ 12 "Switch LETTERS[counter]"
      switch_1 = LETTERS[counter]
      $ 13 "Case 1"
      if (1 == switch_1):
        $ 14 "'a'"
        # 'a'
      elif (2 == switch_1):
        $ 15 "Case 2"
        $ 16 "'b'"
        # 'b'
      elif (3 == switch_1):
        $ 17 "Case 3"
        $ 18 "'c'"
        # 'c'
      elif (4 == switch_1):
        $ 19 "Case 4"
        $ 20 "'d'"
        # 'd'
        $ 21 "Wait: 1.0"
        sleep(1.0)
        $ 22 "MoveJ"
        $ 23 "curr_pos≔pose_trans(curr_pos, p[0.65/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0.65/100,0,0,0,0,0])
        $ 25 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 26 "MoveL"
        $ 27 "Call move_down"
        move_down()
        $ 28 "curr_pos≔pose_trans(curr_pos, p[0,2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,2/100,0,0,0,0])
        $ 30 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 31 "end_circle≔curr_pos"
        global end_circle=curr_pos
        $ 33 "Call move_up"
        move_up()
        $ 34 "curr_pos≔pose_trans(curr_pos, p[0,-2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,-2/100,0,0,0,0])
        $ 35 "Call move_down"
        move_down()
        $ 37 "MoveP"
        $ 38 "curr_pos" "breakAfter"
        movep(pose_trans(letter_start, curr_pos), a=1.2, v=0.25, r=0.025)
        $ 39 "circle_via≔pose_trans(curr_pos, p[1.35/100,1/100,0,0,0,0])"
        global circle_via= pose_trans (curr_pos, p[1.35/100,1/100,0,0,0,0])
        $ 40 "CircleMove"
        $ 41 "circle_via" "noBreak"
        $ 42 "end_circle" "breakAfter"
        movec(pose_trans(letter_start, circle_via), pose_trans(letter_start, end_circle), a=1.2, v=0.15, r=0.0)
        $ 43 "MoveL"
        $ 44 "curr_pos≔end_circle"
        global curr_pos=end_circle
        $ 45 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 46 "Call move_up"
        move_up()
        $ 47 "curr_pos≔pose_trans(curr_pos, p[1.35/100,-2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[1.35/100,-2/100,0,0,0,0])
      elif (5 == switch_1):
        $ 48 "Case 5"
        $ 49 "'e'"
        # 'e'
        $ 50 "Wait: 1.0"
        sleep(1.0)
        $ 51 "MoveL"
        $ 52 "Call move_down"
        move_down()
        $ 53 "curr_pos≔pose_trans(curr_pos, p[0,2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,2/100,0,0,0,0])
        $ 54 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 56 "curr_pos≔pose_trans(curr_pos, p[1/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[1/100,0,0,0,0,0])
        $ 57 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 58 "Call move_up"
        move_up()
        $ 60 "curr_pos≔pose_trans( curr_pos,p[-1/100,-2/100,0,0,0,0])"
        global curr_pos= pose_trans ( curr_pos,p[-1/100,-2/100,0,0,0,0])
        $ 62 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 63 "Call move_down"
        move_down()
        $ 64 "curr_pos≔pose_trans(curr_pos, p[1.1/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[1.1/100,0,0,0,0,0])
        $ 65 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 66 "Call move_up"
        move_up()
        $ 67 "curr_pos≔pose_trans(curr_pos,p[-1.1/100,0.9/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos,p[-1.1/100,0.9/100,0,0,0,0])
        $ 68 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 69 "Call move_down"
        move_down()
        $ 70 "curr_pos≔pose_trans(curr_pos, p[1/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[1/100,0,0,0,0,0])
        $ 71 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 72 "Popup"
        popup(str_cat("",curr_pos), "Message", False, False, blocking=True)
        $ 73 "Call move_up"
        move_up()
        $ 74 "curr_pos≔pose_trans(curr_pos, p[0.1/100,-0.9/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0.1/100,-0.9/100,0,0,0,0])
        $ 75 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
      elif (6 == switch_1):
        $ 77 "Case 6"
        $ 78 "'f'"
        # 'f'
      elif (7 == switch_1):
        $ 79 "Case 7"
        $ 80 "'g'"
        # 'g'
      elif (8 == switch_1):
        $ 81 "Case 8"
        $ 82 "'h'"
        # 'h'
      elif (9 == switch_1):
        $ 83 "Case 9"
        $ 84 "'i'"
        # 'i'
      elif (10 == switch_1):
        $ 85 "Case 10"
        $ 86 "'j'"
        # 'j'
      elif (11 == switch_1):
        $ 87 "Case 11"
        $ 88 "'k'"
        # 'k'
      elif (12 == switch_1):
        $ 89 "Case 12"
        $ 90 "'l'"
        # 'l'
        $ 91 "Wait: 1.0"
        sleep(1.0)
        $ 92 "MoveL"
        $ 93 "curr_pos≔pose_trans(curr_pos, p[0.7/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0.7/100,0,0,0,0,0])
        $ 94 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 95 "Call move_down"
        move_down()
        $ 96 "curr_pos≔pose_trans(curr_pos, p[0,2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,2/100,0,0,0,0])
        $ 97 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 98 "curr_pos≔pose_trans(curr_pos, p[1/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[1/100,0,0,0,0,0])
        $ 99 "curr_pos" "breakAfter"
        movel(pose_trans(letter_start, curr_pos), a=1.2, v=0.25)
        $ 100 "Call move_up"
        move_up()
        $ 101 "curr_pos≔pose_trans(curr_pos,p[0.2/100,-2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos,p[0.2/100,-2/100,0,0,0,0])
      elif (13 == switch_1):
        $ 102 "Case 13"
        $ 103 "'m'"
        # 'm'
      elif (14 == switch_1):
        $ 104 "Case 14"
        $ 105 "'n'"
        # 'n'
        $ 106 "Wait: 1.0"
        sleep(1.0)
        $ 107 "MoveJ"
        $ 108 "curr_pos≔pose_trans(curr_pos, p[0.3/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0.3/100,0,0,0,0,0])
        $ 109 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 110 "Call move_down"
        move_down()
        $ 111 "curr_pos≔pose_trans(curr_pos, p[0,2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,2/100,0,0,0,0])
        $ 112 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 113 "Call move_up"
        move_up()
        $ 114 "curr_pos≔pose_trans(curr_pos, p[0,-2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,-2/100,0,0,0,0])
        $ 115 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 116 "Call move_down"
        move_down()
        $ 117 "curr_pos≔pose_trans(curr_pos, p[1.25/100,2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[1.25/100,2/100,0,0,0,0])
        $ 118 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 119 "Call move_up"
        move_up()
        $ 120 "curr_pos≔pose_trans(curr_pos, p[0,-2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,-2/100,0,0,0,0])
        $ 121 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 122 "Call move_down"
        move_down()
        $ 123 "curr_pos≔pose_trans(curr_pos, p[0,2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,2/100,0,0,0,0])
        $ 124 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 125 "Call move_up"
        move_up()
        $ 126 "curr_pos≔pose_trans(curr_pos, p[0.2/100,-2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0.2/100,-2/100,0,0,0,0])
      elif (15 == switch_1):
        $ 127 "Case 15"
        $ 128 "'o'"
        # 'o'
      elif (16 == switch_1):
        $ 129 "Case 16"
        $ 130 "'p'"
        # 'p'
      elif (17 == switch_1):
        $ 131 "Case 17"
        $ 132 "'q'"
        # 'q'
      elif (18 == switch_1):
        $ 133 "Case 18"
        $ 134 "'r'"
        # 'r'
      elif (19 == switch_1):
        $ 135 "Case 19"
        $ 136 "'s'"
        # 's'
      elif (20 == switch_1):
        $ 137 "Case 20"
        $ 138 "'t'"
        # 't'
      elif (21 == switch_1):
        $ 139 "Case 21"
        $ 140 "'u'"
        # 'u'
      elif (22 == switch_1):
        $ 141 "Case 22"
        $ 142 "'v'"
        # 'v'
      elif (23 == switch_1):
        $ 143 "Case 23"
        $ 144 "'w'"
        # 'w'
      elif (24 == switch_1):
        $ 145 "Case 24"
        $ 146 "'x'"
        # 'x'
      elif (25 == switch_1):
        $ 147 "Case 25"
        $ 148 "'y'"
        # 'y'
        $ 149 "Wait: 1.0"
        sleep(1.0)
        $ 150 "MoveJ"
        $ 151 "curr_pos≔pose_trans(curr_pos, p[0.3/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0.3/100,0,0,0,0,0])
        $ 152 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 153 "Call move_down"
        move_down()
        $ 154 "curr_pos≔pose_trans(curr_pos, p[0.8/100,1.3/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0.8/100,1.3/100,0,0,0,0])
        $ 155 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 156 "Call move_up"
        move_up()
        $ 157 "curr_pos≔pose_trans(curr_pos, p[0.8/100,-1.3/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0.8/100,-1.3/100,0,0,0,0])
        $ 158 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 159 "Call move_down"
        move_down()
        $ 160 "curr_pos≔pose_trans(curr_pos, p[-0.8/100,1.3/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[-0.8/100,1.3/100,0,0,0,0])
        $ 161 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 162 "curr_pos≔pose_trans(curr_pos, p[0,0.8/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[0,0.8/100,0,0,0,0])
        $ 163 "curr_pos" "breakAfter"
        movej(pose_trans(letter_start, curr_pos), a=1.3962634015954636, v=1.0471975511965976)
        $ 164 "Call move_up"
        move_up()
        $ 165 "curr_pos≔pose_trans(curr_pos, p[1/100,-2/100,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[1/100,-2/100,0,0,0,0])
      elif (26 == switch_1):
        $ 166 "Case 26"
        $ 167 "'z'"
        # 'z'
      elif (27 == switch_1):
        $ 168 "Case 27"
        $ 169 "'space'"
        # 'space'
        $ 170 "Wait: 1.0"
        sleep(1.0)
        $ 171 "curr_pos≔pose_trans(curr_pos, p[2.2/100,0,0,0,0,0])"
        global curr_pos= pose_trans (curr_pos, p[2.2/100,0,0,0,0,0])
      end
      $ 172 "counter≔counter+1"
      global counter=counter+1
    end
    $ 173 "MoveJ"
    $ 174 "start_corner" "breakAfter"
    movej(get_inverse_kin(pose_trans(letter_start, pose_trans(p[.651827027168, .309409199398, .071053077952, -2.740114821230, -1.531898493235, -.002604394761], start_corner_p)), qnear=start_corner_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 175 "Popup: Program completed"
    popup("Program completed", "Message", False, False, blocking=False)
    halt
    # begin: URCap Program Node
    #   Source: External Control, 1.0.4, FZI Research Center for Information Technology
    #   Type: External Control
    $ 176 "Control by 192.168.56.1"
popup("The connection to the remote PC at 192.168.56.1:50002 could not be established. Reason: No route to host (Host unreachable)","Receive program failed", False, True, blocking=True)
sync()    # end: URCap Program Node
  end
end
